
<!DOCTYPE html>
<html lang="ca">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GeoSTL Maker - Disseny Geogr√†fic 3D</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; overflow: hidden; background-color: #f8fafc; font-family: ui-sans-serif, system-ui, sans-serif; }
        #root { height: 100vh; }
        .canvas-container { width: 100%; height: 100%; background: radial-gradient(circle, #f8fafc 0%, #e2e8f0 100%); }
        input[type="range"] { cursor: pointer; }
    </style>
<script type="importmap">
{
  "imports": {
    "react": "https://esm.sh/react@^19.2.4",
    "@react-three/fiber": "https://esm.sh/@react-three/fiber@^9.5.0",
    "@react-three/drei": "https://esm.sh/@react-three/drei@^10.7.7",
    "three": "https://esm.sh/three@^0.182.0",
    "react/": "https://esm.sh/react@^19.2.4/"
  }
}
</script>
<!--<link rel="stylesheet" href="/index.css">-->
</head>
<body>
    <div id="root"></div>

    <script type="module">
        // Importem tot des d'una mateixa font per evitar conflictes de context
        import React, { useState, useCallback, useEffect, useRef, useMemo } from 'https://esm.sh/react@19.0.0';
        import ReactDOM from 'https://esm.sh/react-dom@19.0.0/client';
        import htm from 'https://esm.sh/htm';
        import * as THREE from 'https://esm.sh/three@0.174.0';
        import { Canvas } from 'https://esm.sh/@react-three/fiber@8.17.14?external=three';
        import { OrbitControls, PerspectiveCamera, Environment, Grid, Center } from 'https://esm.sh/@react-three/drei@9.121.4?external=three,react,react-dom';

        const html = htm.bind(React.createElement);

        // --- L√íGICA DE TERRENY ---
        class SimpleNoise {
            constructor(seed = 123) {
                this.p = new Array(512);
                const perm = new Array(256).fill(0).map((_, i) => i);
                let s = seed;
                const lcg = () => (s = (s * 1664525 + 1013904223) % 4294967296) / 4294967296;
                for (let i = 255; i > 0; i--) {
                    const j = Math.floor(lcg() * (i + 1));
                    [perm[i], perm[j]] = [perm[j], perm[i]];
                }
                for (let i = 0; i < 512; i++) this.p[i] = perm[i & 255];
            }
            fade(t) { return t * t * t * (t * (t * 6 - 15) + 10); }
            lerp(t, a, b) { return a + t * (b - a); }
            grad(h, x, y, z) {
                const i = h & 15;
                const u = i < 8 ? x : y, v = i < 4 ? y : i === 12 || i === 14 ? x : z;
                return ((i & 1) === 0 ? u : -u) + ((i & 2) === 0 ? v : -v);
            }
            noise2D(x, y) {
                const X = Math.floor(x) & 255, Y = Math.floor(y) & 255;
                x -= Math.floor(x); y -= Math.floor(y);
                const u = this.fade(x), v = this.fade(y);
                const A = this.p[X] + Y, AA = this.p[A], AB = this.p[A + 1];
                const B = this.p[X + 1] + Y, BA = this.p[B], BB = this.p[B + 1];
                return this.lerp(v, this.lerp(u, this.grad(this.p[AA], x, y, 0), this.grad(this.p[BA], x - 1, y, 0)),
                                    this.lerp(u, this.grad(this.p[AB], x, y - 1, 0), this.grad(this.p[BB], x - 1, y - 1, 0)));
            }
        }

        const LandformType = {
            ISLAND: 'Illa', ARCHIPELAGO: 'Arxip√®lag', BAY: 'Badia', CAPE: 'Cap', PENINSULA: 'Pen√≠nsula',
            VALLEY: 'Vall', PLATEAU: 'Podi / Meseta', MOUNTAIN: 'Muntanya', RANGE: 'Serralada',
            LAKES: 'Llacs', ISTHMUS: 'Istme', CANYON: 'Cany√≥', VOLCANO: 'Volc√†'
        };

        const generateTerrain = (p) => {
            const noise = new SimpleNoise(p.seed), shape = new SimpleNoise(p.seed + 99);
            const res = p.resolution, step = p.size / res, half = p.size / 2;
            const pos = new Float32Array((res + 1) * (res + 1) * 3);
            const idx = new Uint32Array(res * res * 6);

            for (let i = 0; i <= res; i++) {
                for (let j = 0; j <= res; j++) {
                    const nx = i / res, ny = j / res;
                    const dnx = nx + shape.noise2D(nx * 2, ny * 2) * p.distortion * 0.3;
                    const dny = ny + shape.noise2D(ny * 2, nx * 2) * p.distortion * 0.3;
                    const dist = Math.sqrt(Math.pow(dnx - 0.5, 2) + Math.pow(dny - 0.5, 2)) * 2;
                    let h = 0, amp = 1, f = p.noiseScale;
                    for (let o = 0; o < 4; o++) { h += noise.noise2D(nx * f, ny * f) * amp; amp *= p.roughness; f *= 2; }
                    h = (h + 1) / 2;
                    let mask = 1;
                    if (p.type === LandformType.ISLAND) mask = Math.max(0, 1 - dist * 1.4);
                    else if (p.type === LandformType.MOUNTAIN) mask = Math.pow(Math.max(0, 1 - dist * 1.6), 2);
                    else if (p.type === LandformType.VOLCANO) mask = Math.pow(Math.max(0, 1 - dist * 1.4), 1.6) * (dist < 0.15 ? Math.pow(dist/0.15, 2) : 1);
                    else if (p.type === LandformType.PENINSULA) mask = Math.max(nx < 0.4 ? (1 - Math.abs(ny-0.5)/0.25) : 0, Math.max(0, 1 - Math.sqrt(Math.pow(nx-0.5,2)+Math.pow(ny-0.5,2)*0.8)*2.5));

                    const fh = (h * mask * p.maxHeight) + p.baseThickness;
                    const k = i * (res + 1) + j;
                    pos[k * 3] = i * step - half; pos[k * 3 + 1] = fh; pos[k * 3 + 2] = j * step - half;
                }
            }
            let c = 0;
            for (let i = 0; i < res; i++) {
                for (let j = 0; j < res; j++) {
                    const a = i * (res+1) + j, b = (i+1) * (res+1) + j, d = i * (res+1) + (j+1), e = (i+1) * (res+1) + (j+1);
                    idx[c++] = a; idx[c++] = d; idx[c++] = b; idx[c++] = b; idx[c++] = d; idx[c++] = e;
                }
            }
            return { positions: pos, indices: idx };
        };

        const exportSTL = (m) => {
            let s = "solid Geo\n";
            const g = (i) => [m.positions[i*3], m.positions[i*3+1], m.positions[i*3+2]];
            for (let i = 0; i < m.indices.length; i += 3) {
                const v1 = g(m.indices[i]), v2 = g(m.indices[i+1]), v3 = g(m.indices[i+2]);
                s += `facet normal 0 0 0\nouter loop\nvertex ${v1[0]} ${v1[1]} ${v1[2]}\nvertex ${v2[0]} ${v2[1]} ${v2[2]}\nvertex ${v3[0]} ${v3[1]} ${v3[2]}\nendloop\nendfacet\n`;
            }
            return s + "endsolid Geo\n";
        };

        // --- COMPONENTS ---
        const Viewer = ({ meshData, params }) => {
            const geo = useMemo(() => {
                const g = new THREE.BufferGeometry();
                g.setAttribute('position', new THREE.BufferAttribute(meshData.positions, 3));
                g.setIndex(new THREE.BufferAttribute(meshData.indices, 1));
                g.computeVertexNormals();
                return g;
            }, [meshData]);

            return html`
                <${Canvas} shadows>
                    <${PerspectiveCamera} makeDefault position=${[params.size, params.size, params.size]} fov=${45} />
                    <${OrbitControls} makeDefault />
                    <ambientLight intensity=${1} />
                    <directionalLight position=${[50, 100, 50]} intensity=${1.5} />
                    <${Center} top>
                        <mesh geometry=${geo}>
                            <meshStandardMaterial color="#3b82f6" roughness=${0.6} />
                        </mesh>
                    <//>
                    <${Grid} infiniteGrid cellSize=${10} sectionSize=${50} sectionColor="#94a3b8" />
                    <${Environment} preset="city" />
                <//>
            `;
        };

        const App = () => {
            const [p, setP] = useState({ type: LandformType.ISLAND, size: 100, maxHeight: 25, resolution: 64, noiseScale: 4, roughness: 0.5, distortion: 0.4, seed: 42, baseThickness: 3 });
            const [mesh, setMesh] = useState(null);

            useEffect(() => setMesh(generateTerrain(p)), [p]);

            const dl = () => {
                const blob = new Blob([exportSTL(mesh)], { type: 'text/plain' });
                const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = `Geo_${p.type}.stl`; a.click();
            };

            return html`
                <div className="flex flex-col md:flex-row h-screen w-full">
                    <div className="w-full md:w-80 bg-white border-r p-6 overflow-y-auto flex flex-col z-10 shadow-xl">
                        <h1 className="text-xl font-black mb-6 flex items-center gap-2">
                            <span className="bg-blue-600 text-white p-1 rounded">G</span> GeoSTL Maker
                        </h1>
                        <div className="space-y-4 flex-1">
                            <div>
                                <label className="text-[10px] font-bold text-slate-400 uppercase">Tipus</label>
                                <select className="w-full p-2 bg-slate-100 rounded-lg font-bold outline-none" value=${p.type} onChange=${e => setP({...p, type: e.target.value})}>
                                    ${Object.values(LandformType).map(t => html`<option key=${t} value=${t}>${t}</option>`)}
                                </select>
                            </div>
                            <div>
                                <label className="text-[10px] font-bold text-slate-400 uppercase">Seed: ${p.seed}</label>
                                <div className="flex gap-2">
                                    <input type="number" className="flex-1 p-2 bg-slate-100 rounded-lg" value=${p.seed} onChange=${e => setP({...p, seed: parseInt(e.target.value)||0})} />
                                    <button onClick=${() => setP({...p, seed: Math.floor(Math.random()*9999)})} className="p-2 bg-slate-200 rounded">üé≤</button>
                                </div>
                            </div>
                            <div>
                                <label className="text-[10px] font-bold text-slate-400 uppercase">Mida: ${p.size}mm</label>
                                <input type="range" min="20" max="200" className="w-full" value=${p.size} onChange=${e => setP({...p, size: parseInt(e.target.value)})} />
                            </div>
                            <div>
                                <label className="text-[10px] font-bold text-slate-400 uppercase">Altura: ${p.maxHeight}mm</label>
                                <input type="range" min="5" max="80" className="w-full" value=${p.maxHeight} onChange=${e => setP({...p, maxHeight: parseInt(e.target.value)})} />
                            </div>
                        </div>
                        <button onClick=${dl} className="mt-6 w-full py-3 bg-blue-600 text-white font-bold rounded-xl hover:bg-blue-700 shadow-lg">Descarregar STL</button>
                        <div className="mt-6 text-[9px] text-slate-400 leading-tight">
                            <p>Llic√®ncia: GNU GPL</p>
                            <p>Autoria: Aar√≥n Fortu√±o & Gemini AI</p>
                        </div>
                    </div>
                    <div className="flex-1 relative bg-slate-100">
                        ${mesh && html`<${Viewer} meshData=${mesh} params=${p} />`}
                    </div>
                </div>
            `;
        };

        ReactDOM.createRoot(document.getElementById('root')).render(html`<${App} />`);
    </script>
<!--<script type="module" src="/index.tsx"></script>-->
</body>
</html>
